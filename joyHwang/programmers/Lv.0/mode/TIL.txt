reduce 메서드

array.reduce 를 이용해 초기값을 {} 빈 객체로 설정하고, 키와 값을 셋팅해준다.

예1의 경우를 살펴보면 element에 1이 들어왔을 때 acc[1]는 아직 해당 요소 1을 키로 하는 속성이 존재하지 않기 때문에 || 연산자 뒤의 0이 사용되게 된다. 그리고 후에 '+ 1'을 통해 빈도수가 1로 증가한다.

그리고 이 코드 실행 후에 객체에 {1: 1} 이란 키:값이 추가되게 되고, acc는 계속해서 누적된 값이 들어오기 때문에 {1: 1, 2: 1, 3: 3, 4:1} 결과적으로 이런 객체가 생성되게 된다.

 

예1에서 array가 [1, 2, 3, 3, 3, 4]인데, acc[3]의 경우 3번을 거치면서 값이 기존 값에 + 1 씩 누적되게 되니까 3: 3 으로 저장된다.

Object.values로 객체의 값들을 배열로 변환하면[1,1,3,1] 값이 되는데 ...(스프레드 연산자) 로 배열을 개별 요소들로 분리시킨 후 Math.max 해서 가장 높은 빈도수 값 3을 maxCount 변수에 할당해준다.

그런 후 이번엔 Object.keys로 객체의 키들을 배열로 변환해서 find 메서드로 counts[key] ===  maxCount  조건을 만족시키는 값을 찾는다.

그러면 1 === 3, 2 === 3, 3 === 3, 4 === 3 같이 조건을 만족시키는 값을 찾게 되는데 여기서는 그 결과로 3을 뱉는다. 그런 후 return parseInt(mode); 하면 3 이라는 결과가 반환된다. (문자열이 아닌 정수 반환을 위해 parseInt을 사용했다.)


예2의 경우 array 값으로 [1, 1, 2, 2] 가 들어오는데 알 수 있듯이 이번엔 최빈값이 2개다.

const counts = {1: 2, 2: 2} 이런 객체가 생성될 것이고, Object.values(counts) 하면 [2, 2] 가 되게 된다.

따라서 if 조건문을 추가해서 [2.2].filter(count => count === maxCount).length > 1 조건을 만족하면 -1 을 반환하도록 해줬다.

여기서 maxCount 값은 2가 되기 때문에, 2 === 2 조건을 만족시키는 요소 갯수가 2가 되서 -1이 반환된다.  

/https://ziszini.tistory.com/170